<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Design Patterns: Real-World Examples & Diagrams</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      /* Global Styles */
      body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 0;
        display: flex;
        background: #f0f0f0;
        color: #333;
      }
      a {
        color: #4caf50;
        text-decoration: none;
      }
      a:hover {
        text-decoration: underline;
      }
      /* Sidebar Styles */
      .sidebar {
        width: 250px;
        background-color: #333;
        color: #fff;
        padding: 20px;
        box-sizing: border-box;
        min-height: 100vh;
      }
      .sidebar h2 {
        text-align: center;
        margin-top: 0;
        font-size: 1.6em;
      }
      .sidebar nav details {
        margin-bottom: 10px;
      }
      .sidebar nav details summary {
        cursor: pointer;
        padding: 5px 0;
        font-weight: bold;
        outline: none;
      }
      .sidebar nav ul {
        list-style: none;
        padding-left: 15px;
        margin-top: 5px;
      }
      .sidebar nav ul li {
        margin-bottom: 5px;
      }
      /* Content Styles */
      .content {
        flex: 1;
        padding: 20px;
        box-sizing: border-box;
        overflow-y: auto;
      }
      section {
        background: #fff;
        padding: 20px;
        margin-bottom: 40px;
        border-radius: 4px;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
      }
      section h1 {
        border-bottom: 2px solid #4caf50;
        padding-bottom: 5px;
      }
      section h2 {
        color: #4caf50;
        margin-top: 20px;
      }
      section p,
      section li {
        line-height: 1.6;
      }
      pre {
        background-color: #f4f4f4;
        padding: 10px;
        overflow-x: auto;
        border-radius: 4px;
      }
      code {
        font-family: Consolas, monospace;
      }
      img {
        display: block;
        margin: 15px 0;
        max-width: 100%;
        height: auto;
        border: 1px solid #ccc;
        border-radius: 4px;
      }
      /* Responsive Design */
      @media (max-width: 768px) {
        body {
          flex-direction: column;
        }
        .sidebar {
          width: 100%;
          min-height: auto;
        }
      }
    </style>
  </head>
  <body>
    <!-- Sidebar Navigation -->
    <div class="sidebar">
      <h2>Design Patterns</h2>
      <nav>
        <details open>
          <summary>Chapter 1: Introduction</summary>
          <ul>
            <li><a href="#introduction">What are Design Patterns?</a></li>
            <li><a href="#importance">Why Use Them?</a></li>
          </ul>
        </details>
        <details>
          <summary>Chapter 2: Creational Patterns</summary>
          <ul>
            <li><a href="#singleton">Singleton Pattern</a></li>
            <li><a href="#factory">Factory Pattern</a></li>
          </ul>
        </details>
        <details>
          <summary>Chapter 3: Structural Patterns</summary>
          <ul>
            <li><a href="#adapter">Adapter Pattern</a></li>
            <li><a href="#decorator">Decorator Pattern</a></li>
          </ul>
        </details>
        <details>
          <summary>Chapter 4: Behavioral Patterns</summary>
          <ul>
            <li><a href="#observer">Observer Pattern</a></li>
            <li><a href="#strategy">Strategy Pattern</a></li>
          </ul>
        </details>
        <details>
          <summary>Chapter 5: Real-World & GUI Patterns</summary>
          <ul>
            <li><a href="#mvc">MVC Pattern</a></li>
            <li><a href="#module">Module Pattern</a></li>
          </ul>
        </details>
      </nav>
    </div>

    <!-- Main Content Area -->
    <div class="content">
      <!-- Chapter 1: Introduction -->
      <section id="introduction">
        <h1>Chapter 1: Introduction to Design Patterns</h1>
        <h2>What are Design Patterns?</h2>
        <p>
          Design Patterns are time-tested, reusable solutions to common problems
          in software design. They provide a common vocabulary and are a
          blueprint for solving issues in your code.
        </p>
        <h2 id="importance">Why Use Them?</h2>
        <p>
          They help increase code reusability, improve maintainability, and
          facilitate communication among developers by providing proven
          approaches to common challenges.
        </p>
      </section>

      <!-- Chapter 2: Creational Patterns -->
      <section id="singleton">
        <h1>Chapter 2: Creational Patterns</h1>
        <h2>Singleton Pattern</h2>
        <p>
          The Singleton Pattern ensures that a class has only one instance and
          provides a global point of access to it.
        </p>
        <img
          src="https://upload.wikimedia.org/wikipedia/commons/c/cb/Singleton_UML_class_diagram.svg"
          alt="Singleton UML Diagram"
        />
        <h3>JavaScript Code Example</h3>
        <pre><code>
// Singleton in JavaScript
const Singleton = (function () {
  let instance;
  
  function createInstance() {
    const object = new Object("I am the instance");
    return object;
  }
  
  return {
    getInstance: function () {
      if (!instance) {
        instance = createInstance();
      }
      return instance;
    }
  };
})();

const instance1 = Singleton.getInstance();
const instance2 = Singleton.getInstance();
console.log(instance1 === instance2); // true
      </code></pre>
        <p>
          <em>Explanation:</em> This code demonstrates the Singleton pattern by
          ensuring that only one instance of an object is created and reused.
        </p>
      </section>

      <section id="factory">
        <h2>Factory Pattern</h2>
        <p>
          The Factory Pattern provides a way to create objects without exposing
          the creation logic to the client and refers to the newly created
          objects using a common interface.
        </p>
        <img
          src="https://refactoring.guru/images/patterns/factory-method/structure.png"
          alt="Factory Pattern Diagram"
        />
        <h3>JavaScript Code Example</h3>
        <pre><code>
// Factory Pattern in JavaScript
class Car {
  constructor(options) {
    this.doors = options.doors || 4;
    this.color = options.color || "silver";
  }
}

class CarFactory {
  createCar(options) {
    return new Car(options);
  }
}

const factory = new CarFactory();
const myCar = factory.createCar({ doors: 2, color: "red" });
console.log(myCar);
      </code></pre>
        <p>
          <em>Explanation:</em> This example uses a factory to create car
          objects based on the provided options, abstracting the instantiation
          logic from the client.
        </p>
      </section>

      <!-- Chapter 3: Structural Patterns -->
      <section id="adapter">
        <h1>Chapter 3: Structural Patterns</h1>
        <h2>Adapter Pattern</h2>
        <p>
          The Adapter Pattern allows two incompatible interfaces to work
          together. It converts the interface of a class into another interface
          that clients expect.
        </p>
        <img
          src="https://refactoring.guru/images/patterns/adapter/structure.png"
          alt="Adapter Pattern Diagram"
        />
        <h3>JavaScript Code Example</h3>
        <pre><code>
// Adapter Pattern in JavaScript
class OldCalculator {
  add(a, b) {
    return a + b;
  }
}

class NewCalculator {
  addNumbers(a, b) {
    return a + b;
  }
}

class CalculatorAdapter {
  constructor() {
    this.newCalculator = new NewCalculator();
  }
  
  add(a, b) {
    return this.newCalculator.addNumbers(a, b);
  }
}

const calculator = new CalculatorAdapter();
console.log(calculator.add(5, 10)); // 15
      </code></pre>
        <p>
          <em>Explanation:</em> This adapter wraps the new calculator, providing
          an interface that matches the old calculator's method signature.
        </p>
      </section>

      <section id="decorator">
        <h2>Decorator Pattern</h2>
        <p>
          The Decorator Pattern dynamically adds responsibilities to an object.
          This pattern provides a flexible alternative to subclassing for
          extending functionality.
        </p>
        <img
          src="https://refactoring.guru/images/patterns/decorator/structure.png"
          alt="Decorator Pattern Diagram"
        />
        <h3>JavaScript Code Example</h3>
        <pre><code>
// Decorator Pattern in JavaScript
class SimpleCoffee {
  cost() {
    return 2;
  }
}

class MilkDecorator {
  constructor(coffee) {
    this.coffee = coffee;
  }
  cost() {
    return this.coffee.cost() + 0.5;
  }
}

let coffee = new SimpleCoffee();
coffee = new MilkDecorator(coffee);
console.log(coffee.cost()); // 2.5
      </code></pre>
        <p>
          <em>Explanation:</em> The <code>MilkDecorator</code> adds extra cost
          to the basic coffee without modifying the original
          <code>SimpleCoffee</code> class.
        </p>
      </section>

      <!-- Chapter 4: Behavioral Patterns -->
      <section id="observer">
        <h1>Chapter 4: Behavioral Patterns</h1>
        <h2>Observer Pattern</h2>
        <p>
          The Observer Pattern defines a one-to-many dependency between objects
          so that when one object changes state, all its dependents are notified
          automatically.
        </p>
        <img
          src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/3c/Observer_pattern.svg/600px-Observer_pattern.svg.png"
          alt="Observer Pattern Diagram"
        />
        <h3>JavaScript Code Example</h3>
        <pre><code>
// Observer Pattern in JavaScript
class Subject {
  constructor() {
    this.observers = [];
  }
  subscribe(observer) {
    this.observers.push(observer);
  }
  unsubscribe(observer) {
    this.observers = this.observers.filter(obs => obs !== observer);
  }
  notify(data) {
    this.observers.forEach(observer => observer.update(data));
  }
}

class Observer {
  update(data) {
    console.log("Observer received data:", data);
  }
}

const subject = new Subject();
const observer1 = new Observer();
const observer2 = new Observer();
subject.subscribe(observer1);
subject.subscribe(observer2);
subject.notify("Hello Observers!");
      </code></pre>
        <p>
          <em>Explanation:</em> This implementation demonstrates how multiple
          observers are notified when the subjectâ€™s state changes.
        </p>
      </section>

      <section id="strategy">
        <h2>Strategy Pattern</h2>
        <p>
          The Strategy Pattern enables selecting an algorithm's behavior at
          runtime. It defines a family of algorithms, encapsulates each one, and
          makes them interchangeable.
        </p>
        <img
          src="https://refactoring.guru/images/patterns/strategy/structure.png"
          alt="Strategy Pattern Diagram"
        />
        <h3>JavaScript Code Example</h3>
        <pre><code>
// Strategy Pattern in JavaScript
class StrategyA {
  execute(a, b) {
    return a + b;
  }
}

class StrategyB {
  execute(a, b) {
    return a * b;
  }
}

class Context {
  setStrategy(strategy) {
    this.strategy = strategy;
  }
  executeStrategy(a, b) {
    return this.strategy.execute(a, b);
  }
}

const context = new Context();
context.setStrategy(new StrategyA());
console.log(context.executeStrategy(5, 10)); // 15
context.setStrategy(new StrategyB());
console.log(context.executeStrategy(5, 10)); // 50
      </code></pre>
        <p>
          <em>Explanation:</em> This code illustrates how different strategies
          can be swapped at runtime to change the algorithm's behavior.
        </p>
      </section>

      <!-- Chapter 5: Real-World & GUI Patterns -->
      <section id="mvc">
        <h1>Chapter 5: Real-World Examples & GUI Patterns</h1>
        <h2>MVC Pattern</h2>
        <p>
          The Model-View-Controller (MVC) Pattern divides an application into
          three interconnected components. This separation helps manage
          complexity in large applications.
        </p>
        <img
          src="https://upload.wikimedia.org/wikipedia/commons/2/2d/MVC-Overview.svg"
          alt="MVC Pattern Diagram"
        />
        <h3>Example Explanation</h3>
        <p>
          <strong>Model:</strong> Manages data and business logic.<br />
          <strong>View:</strong> Presents data to the user.<br />
          <strong>Controller:</strong> Handles input and updates the Model and
          View.
        </p>
      </section>

      <section id="module">
        <h2>Module Pattern</h2>
        <p>
          The Module Pattern encapsulates private variables and functions,
          exposing only a public API. It is widely used for organizing and
          structuring code.
        </p>
        <img
          src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/2b/Module_pattern.svg/600px-Module_pattern.svg.png"
          alt="Module Pattern Diagram"
        />
        <h3>JavaScript Code Example</h3>
        <pre><code>
// Module Pattern in JavaScript
const myModule = (function() {
  let privateVar = "I am private";
  
  function privateMethod() {
    return privateVar;
  }
  
  return {
    publicMethod: function() {
      return privateMethod();
    }
  };
})();

console.log(myModule.publicMethod()); // "I am private"
      </code></pre>
        <p>
          <em>Explanation:</em> This example encapsulates private data and
          functionality, exposing only a public method for external access.
        </p>
      </section>
    </div>
  </body>
</html>
